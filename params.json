{"name":"Rbo-tinyos-java","tagline":"","body":"# Programs in Java for testing and simulations of RBO.\r\n\r\nRBO is a simple and robust broadcast-scheduling protocol minimizing\r\n'tuning-time/energy' of the receiver.\r\nIt's idea is based on an interesting property of the bit-reversal permutation.\r\nThe broadcast cycle is a sorted sequence of keys of length 2^k, permuted by k-bit-reversal\r\npermutation. \r\nThe broadcast cycle is broadcast in 'round-robin' fashion by the sender.\r\nThe receiver wants to receive some key from the broadcast cycle.\r\nIt uses a simple RBO protocol that listens to some samples of the broadcast cycle.\r\nIt may start at any time during the broadcasting and, due to the properties of bit-reversal,\r\nthe number of samples to be received is very low, thus saving the energy consumed\r\nby the radio receptions.\r\n\r\nInformal description of the protocol with references to the technical reports\r\ncan be found at: \r\n    https://sites.google.com/site/rboprotocol/\r\n\r\n\r\nThis directory contains a prototype of \r\nthe RBO protocol with a simple test application (and some other code in Java used for testing RBO).\r\n\r\n\r\nThe files Rbo*.java contain implementation of the modules\r\nof the protocol.\r\n\r\n\r\n\r\nThe files Tiny*.java contain emulations of the TinyOS \r\ncomponents used by RBO.\r\n\r\nThe files *Events.java are specifications (parts of module's interfaces) \r\nof the events signalled by the corresponding modules.\r\n\r\n \r\n\r\nTo compile the programs run in this directory:\r\n\r\n   javac *.java\r\n\r\n\r\nSIMPLE TEST APPLICATION:\r\n------------------------\r\n\r\nTo start simple test application of the protocol run:\r\n\r\n   java TestApplication logSequenceLength timeSlotLength\r\n\r\nwhere \r\n   logSequenceLength is logarithm of the length of the transmitted sequence\r\n   (here it should be less than 30 - we are using Java type int)\r\nand \r\n  timeSlotLength is the time between transmissions of consecutive elements\r\n   (in milliseconds) \r\nThis program creates two windows: for the sender and for the receiver. \r\n(* Note that, initially, one window may be covered by the other. Use the mouse to relocate them. *)\r\nThe keys in the sequence broadcast by the sender are consecutive positive \r\nodd numbers (starting from 1),\r\nwhile the receiver selects as the searched key a random integer\r\nbetween 0 and 1+(maximum of the broadcast sequence).\r\nThere is also simple menu in the terminal for printing statistics\r\nand stopping/restarting the receiver/sender.\r\n\r\nThe messages in the receivers' window are printed after completion of each search.\r\nThey look like this:\r\n\r\n 50.searchDone: ERR:2 MSG: H:ID=2 LSL=13 TSL=2 KEY=15769 RNK=7884 P:7884\r\n\r\nERR - status of the result ( 0 - SUCCESS, 1 - TIME_OUT, 2 - KEY_NOT_PRESENT)\r\nID -  sequence ID\r\nLSL - logarithm of sequence length\r\nTSL - time of sequence length\r\nKEY - the key in last received message\r\nRNK - rank of the key\r\nP   - payload\r\n\r\nThe messages in the senders' window are printed after each round of \r\nsequence transmission.\r\n\r\nThe time in statistics is given in milliseconds.\r\n\r\n(* Note that it is 'real-time' simulation. \r\nHence, the time intervals between subsequent messages \r\nmay be quite long for large broadcast cycles. *)\r\n\r\n\r\n--\r\n\r\nThe author can be reached at: \r\n    Marcin.Kik@pwr.wroc.pl\r\nor\r\n    mki1967@gmail.com\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}